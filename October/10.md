### Accessing Session on the Server
We can start by opening our `route.ts` file inside `[...nextauth]` and export the const `authOptions` like it shows below.
```
import NextAuth from "next-auth";
import GoogleProvider from "next-auth/providers/google";

export const authOptions = {
    providers: [
        GoogleProvider({
            clientId: process.env.GOOGLE_CLIENT_ID!,
            clientSecret: process.env.GOOGLE_CLIENT_SECRET!
        })
    ]
};

const handler = NextAuth(authOptions)

export { handler as GET, handler as POST }
```
Doing this will allow us to gain access on the home page in the root folder called `page.tsx` and then implement the `useServersession` function.
```
import Link from 'next/link';
import ProductCard from './components/ProductCard/ProductCard';
import { getServerSession } from 'next-auth';
import { authOptions } from './api/auth/[...nextauth]/route';

export default async function Home() {
 const session = await getServerSession(authOptions)

  return (
    <main>
      <h1>Hello { session && <span>{session.user!.name}</span>}</h1>
      <Link href="/users">Users</Link>
      <ProductCard />
    </main>
  );
}
```
With this we can render the session inside the `<h1>` to display the name of the user logged-in.

### Signing out users
In the navbar we can add a `<Link>` component for signing out.
```
{ status === 'authenticated' && 
      <div>
        {session.user!.name}
        <Link href='/api/auth/signout' className='ml-3'>Sign Out</Link>
      </div>}
```
The `signout` is another endpoint that is handled by `NextAuth`. We can click on the signout link on the browser and sign out.

### Protecting Routes
On the top outside the `app` folder create a file called `middleware.ts`, then we export the function.
```
import { NextRequest, NextResponse } from "next/server";

export function middleware(request: NextRequest) {
    return NextResponse.redirect(new URL('/new-page', request.url))
}
```
This is just an example as the Url `'/new-page'` doesn't exist.

We can simplify this code by just using a few lines of code on the go. This a way to protect the routes.
```
export { default } from "next-auth/middleware";

export const config = {
    matcher: ['/users/:id*']
}
```
### Database Adapters
On `NextAuth.js.org` there is a page for adapters. There's a few to choose from but the one we will be using is `Prisma`.
In the terminal run `npm i @next-auth/prisma-adapter`, then import it, `import { PrismaAdapter } from "@next-auth/prisma-adapter";`
as well as `import { prisma } from "@/prisma/client";` and add the `adapter` property and set it to `PrismaAdapter` `adapter: PrismaAdapter(prisma)`.

The next step is to add a bunch of models to our `prisma.schema`. We first delete the two models from the prisma file and then run `npx prisma migrate dev`. Then we copy this code from the documentation and paste in the `prisma.schema` file.
```
model Account {
  id                 String  @id @default(cuid())
  userId             String
  type               String
  provider           String
  providerAccountId  String
  refresh_token      String?  @db.Text
  access_token       String?  @db.Text
  expires_at         Int?
  token_type         String?
  scope              String?
  id_token           String?  @db.Text
  session_state      String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}
```
We run `npx prisma migrate dev` one more time and name our new migrations. We can test the implementation by logging in and then checking on the `Datagrid` if the information is stored on the database.
